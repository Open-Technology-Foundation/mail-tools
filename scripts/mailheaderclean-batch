#!/bin/bash
# Clean non-essential email headers from files in-place
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

VERSION='1.0.1'
SCRIPT_PATH=$(readlink -en -- "$0")
SCRIPT_NAME=${SCRIPT_PATH##*/}
readonly -- VERSION SCRIPT_PATH SCRIPT_NAME

declare -i VERBOSE=1

# Color definitions (only if terminal supports)
if [[ -t 1 && -t 2 ]]; then
  declare -- RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -- RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi
readonly -- RED GREEN YELLOW CYAN NC

# Core message function
_msg() {
  local -- prefix="$SCRIPT_NAME:" msg
  case "${FUNCNAME[1]}" in
    success) prefix+=" ${GREEN}✓${NC}" ;;
    warn)    prefix+=" ${YELLOW}⚡${NC}" ;;
    info)    prefix+=" ${CYAN}◉${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
    *)       ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}

# Messaging functions
vecho() { ((VERBOSE)) || return 0; _msg "$@"; }
success() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
error() { >&2 _msg "$@"; }
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

noarg() {
  if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then
    die 2 "Missing argument for option '$1'"
  fi
}

show_help() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Clean non-essential email headers

Remove bloat headers (Microsoft Exchange, tracking, etc.) from email files
in-place while preserving timestamps and essential routing information.

Usage: $SCRIPT_NAME [Options] FILE|DIR [FILE|DIR ...]

Options:
  -d|--days <n>     Only process files newer than n days (default: all files)
  -m|--maxdepth <n> When DIR specified, max depth to traverse (default: 1)
  -v|--verbose      Increase verbosity
  -q|--quiet        Suppress output
  -V|--version      Show version
  -h|--help         Show this help message

Environment Variables:
  MAILHEADERCLEAN          Replace built-in removal list
  MAILHEADERCLEAN_PRESERVE Exclude headers from removal
  MAILHEADERCLEAN_EXTRA    Add headers to removal list

Examples:
  # Clean single file in-place
  $SCRIPT_NAME email.eml

  # Clean all files in directory
  $SCRIPT_NAME /path/to/maildir

  # Clean files modified in last 7 days
  $SCRIPT_NAME -d 7 /path/to/maildir
EOT
  exit "${1:-0}"
}

main() {
  local -a Paths=()
  local -a Files=()
  local -i days=0 maxdepth=1

  # Parse arguments
  while (($#)); do case "$1" in
    -d|--days)      noarg "$@"; shift; days="$1" ;;
    -m|--maxdepth)  noarg "$@"; shift; maxdepth="$1" ;;
    -v|--verbose)   VERBOSE+=1 ;;
    -q|--quiet)     VERBOSE=0 ;;
    -V|--version)   echo "$SCRIPT_NAME $VERSION"; exit 0 ;;
    -h|--help)      show_help 0 ;;
    -[dmvqVh]*) #shellcheck disable=SC2046
                    set -- '' $(printf -- '-%c ' $(grep -o . <<<"${1:1}")) "${@:2}" ;;
    -*)             die 22 "Invalid option '$1'" ;;
    *)              Paths+=("$1") ;;
  esac; shift; done

  # If no paths, exit
  ((${#Paths[@]})) || die 2 "No files to process"

  # Build Files array from paths (files and directories)
  local -- path
  local -a find_args=()
  for path in "${Paths[@]}"; do
    if [[ -f "$path" ]]; then
      Files+=("$path")
    elif [[ -d "$path" ]]; then
      find_args=("$path" -maxdepth "$maxdepth" -type f)
      ((days > 0)) && find_args+=(-mtime -"$days")
      readarray -t -O "${#Files[@]}" Files < <(find "${find_args[@]}" 2>/dev/null || true)
    else
      die 1 "Not a file or directory: '$path'"
    fi
  done

  ((${#Files[@]})) || die 1 'No files to process'

  # Try to load mailheaderclean builtin, fallback to binary
  if ! type -t mailheaderclean >/dev/null; then
    if [[ -f /etc/profile.d/mail-tools.sh ]]; then
      # shellcheck source=/dev/null
      source /etc/profile.d/mail-tools.sh
    else
      enable -f /usr/local/lib/bash/loadables/mailheaderclean.so mailheaderclean 2>/dev/null
    fi
    if ! type -t mailheaderclean >/dev/null; then
      warn "enable builtin mailheaderclean failed"
      command -v mailheaderclean || die 1 "mailheaderclean not found!"
    fi
  fi

  info "Processing ${#Files[@]} email files"
  ((VERBOSE==0)) || >&2 echo

  # Process each file in-place
  local -- file tmpfile
  local -a error_files=()
  local -i filecount=0
  for file in "${Files[@]}"; do
    [[ -r "$file" ]] || { error_files+=("$file"); warn "Cannot read '$file', skipping"; continue; }
    [[ -w "$file" ]] || { error_files+=("$file"); warn "Cannot write '$file', skipping"; continue; }

    tmpfile=$(mktemp "${file}.XXXXXX") || die 1 "Failed to create temp file for '$file'"

    if mailheaderclean "$file" > "$tmpfile"; then
      # Preserve all file attributes (timestamps, permissions, ownership)
      cp --attributes-only --preserve=all "$file" "$tmpfile" 2>/dev/null || true
      mv "$tmpfile" "$file"
      filecount+=1
      ((VERBOSE==0)) || >&2 echo -en "\r$filecount files"
    else
      error_files+=("$file")
      rm -f "$tmpfile"
      warn "Failed to clean headers in '$file'"
    fi
  done
  ((VERBOSE==0)) || >&2 echo

  # Report
  if ((VERBOSE)); then
    if ((${#error_files[@]})); then
      info 'There were errors in these files:'
      for file in "${error_files[@]}"; do vecho "    $file"; done
      echo
    fi
    success "$filecount files processed"
  fi

  return 0
}

main "$@"
#fin
